# データタイプ　「型」

Rustはコンパイラ言語 → 静的型付け → つまり型に厳格です  

軽量プログラミング言語と呼ばれるJavaScriptとか、Perlとか、PHPとか、Rubyとか、Pythonとかは「動的型付け」です。
それらの言語と違って、Rustは何の型を扱っているのかを正しく理解して使わないとエラーになります

例  
足し算
```
fn main() {
    let a: i32 = 10;
    let b: i32 = 20;
    println!("{}", a + b); //これは足せる
}
```
数字でも型が違えば計算できない  
i32型とi64型を足しているのエラー
```
fn main() {
    let c: i32 = 30;
    let d: i64 = 40;
    println!("{}", c + d); //これはエラー
}
```
こういう場合はキャスト(型変換)して合わせる
```
fn main() {
    let c: i32 = 30;
    let d: i64 = 40;
    println!("{}", c + d as i32); //as というキーワードはキャストを行います
}
```

## 型推論

「変数名:型名」と書くのが基本ですが、「:型名」を省いて書いても、コンパイラは型を推論してくれます。  
この場合eは整数、fは小数と大雑把に判断して、型が違うのでエラーになります。
```
fn main() {
    let e = 10;
    let f = 3.14;
    let g = e + f;
    println!("{}", g);
}
```
この場合eはf64にキャストしたので、fもf64と判断して計算されます。
```
fn main() {
    let e = 10;
    let f = 3.14;
    let g = e as f64 + f;
    println!("{}", g);
}
```
この場合fはu8にキャストしたので、eもu8と判断して計算されます。
```
fn main() {
    let e = 10;
    let f = 3.14;
    let g = e + f as u8;
    println!("{}", g);
}
```
これはエラーになります
```
fn main() {
    let e: i32 = 10;
    let f: f64 = 3.14;
    let g = e + f as u8;
    println!("{}", g);
}
```

## 数値型の一覧

|型|最小値|最大値|
|:--|:--|:--|
|i8|-128|127|
|i16|-32768|32767|
|i32|-2147483648|2147483647|
|i64|-9223372036854775808|9223372036854775807|
|u8|0|255|
|u16|0|65535|
|u32|0|4294967295|
|u64|0|18446744073709551615|
|isize|-9223372036854775808|9223372036854775807|
|usize|0|18446744073709551615|
|f32|-3.4028235e38|3.4028235e38|
|f64|-1.7976931348623157e308|1.7976931348623157e308|

## ブーリアン型

bool型。 true と false という2つの値を持ちます。

```
let x = true;
let y: bool = false;
```

## char型

char型は1文字。シングルクオート（'）で囲む（文字列ではない）

```
let x = 'x';
```

## タプル型

下の場合、型は(i32, f64, char)になります。

```
fn main() {
    let t: (i32, f64, char) = (42, 3.14, 'あ');
    //タプルの値にアクセスするには.添字
    println!("{} {} {}", t.0, t.1, t.2);
    //分解して代入できる
    let (a, b, c) = t;
    println!("{} {} {}", a, b, c);
    //使用しない変数はアンダースコア
    let (_, _, z) = t;
    println!("{}", z);
}
```
単一の値からなるタプルを作成する場合、最初の要素の後にコンマを追加
```
fn main() {
    let x: (bool,) = (true,);
    println!("{}", x.0);
}
```
タプル内タプルへのアクセス  
スペースを開けるかカッコで囲う
```
fn main() {
    let t = (1, 2, 3, "abcd", (10, 20, 30));
    println!("{}", t.4 .1); // 20
    println!("{}", (t.4).1); // またはカッコで囲う
}

結果
20
20
```

## 配列型

タプルと異なり、配列の全要素は同じ型でなければなりません。  
Rustの配列は**固定長**です。一度宣言されたら、サイズを伸ばすことも縮めることもできません。

```
fn main() {
    let x = [1, 2, 3];
    let y: [i32; 3] = [4, 5, 6]; // この場合[i32; 3]が型名

    //formatの書き方に注意
    //配列のように複数の値を持つ変数を表示するには{:?}と書きます
    println!("{:?}", x);
    //{:#?}は複数行に分けて表示します
    println!("{:#?}", y);

    //要素にアクセスするのは他の言語と同じ
    println!("{}", y[0]);
    //配列の長さを求める
    println!("{}", x.len());
}

結果
[1, 2, 3]
[
    4,
    5,
    6,
]
4
3
```
タプル(i32, f64, char)型で長さ3の配列
```
fn main() {
    let z: [(i32, f64, char); 3] = [(42, 3.14, 'あ'), (43, 3.14, 'い'), (44, 3.14, 'う')];

    println!("{:?}", z);
    println!("{}", z[1].2);
}

結果
[(42, 3.14, 'あ'), (43, 3.14, 'い'), (44, 3.14, 'う')]
い
```
再代入するにはmut
```
fn main() {
    let mut x = [1, 2, 3];
    x[0] = 100;

    println!("{:?}", x);
}

結果
[100, 2, 3]
```

## スライス型

配列のように一つの変数の中に多くの値が入っているもの全体というより、その内の一連の要素を参照する型がスライス型です。

&記号は参照を意味します。参照とは値そのものではなくて、値のあるアドレスを使用すると考えましょう。  

```
fn main() {
    let a = [1, 2, 3, 4, 5];
    let slice1 = &a[1..3];
    let slice2 = &a[2..];
    let slice3 = &a[..4];
    let slice4 = &a[..];

    println!("{:?}", slice1);
    println!("{:?}", slice2);
    println!("{:?}", slice3);
    println!("{:?}", slice4);
}

結果
[2, 3]
[3, 4, 5]
[1, 2, 3, 4]
[1, 2, 3, 4, 5]
```

## 文字列型

Rustの文字列は難しいです。

#### 文字列型の基本は2つ

### &str型

&が付いているので参照で「文字列スライス」

```
let x = "Hello, World!";
let y: &str = "Isn't it a wonderful life?!";
```

### String型

```
let x = String::from("Hello, World");
let y: String = String::from("Isn't it a wonderful life?!");
```

```
let mut s = String::from("hello");
s.push_str(", world!"); // push_str()関数は、&strをStringに付け加える
println!("{}", s); // これは`hello, world!`と出力する
```

## 文字列の結合はformat!マクロを使う

文字列の結合処理はformat!マクロで行うのがベター  
format!マクロを使うと、&str型でもString型でも自由に結合できます。

```
fn main() {
    //&str型
    let x1 = "Hello,";
    let y1 = "World!";
    let z1 = format!("{} {}", x1, y1);

    //String型
    let x2 = "Hello,".to_string(); //&strに.to_string()メソッドでString型になる
    let y2 = String::from("World!");
    let z2 = format!("{} {}", x2, y2);

    println!("{}", z1);
    println!("{}", z2);
}
```

## Raw文字列の書き方

文字をエスケープをせずにそのまま出力できる

```
fn main() {
    let s = r"はじめ
    
まして

";

    println!("{}", s);

    let s2 = r#""ダブル"
"クォーテーション""#;

    println!("{}", s2);
}

結果
はじめ

まして


"ダブル"
"クォーテーション"
```

